{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Python: 3.12.2 | packaged by conda-forge | (main, Feb 16 2024, 20:54:21) [Clang 16.0.6 ]\n",
            "Data dir exists: False\n",
            "Work dir: /Users/maxwhalen/Documents/GitHub/Big-Data-Bowl-26\n",
            "CUDA available: False\n"
          ]
        }
      ],
      "source": [
        "# Kaggle Submission Notebook: Physics-Informed Residual Trajectory Network (PIRTN)\n",
        "# Self-contained. Reads Kaggle competition data and writes submission.csv.\n",
        "\n",
        "import os\n",
        "import sys\n",
        "from pathlib import Path\n",
        "\n",
        "DATA_DIR = Path(\"/kaggle/input/nfl-big-data-bowl-2026-prediction\")\n",
        "WORK_DIR = Path(\"/kaggle/working\") if DATA_DIR.exists() else Path.cwd()\n",
        "\n",
        "print(\"Python:\", sys.version)\n",
        "print(\"Data dir exists:\", DATA_DIR.exists())\n",
        "print(\"Work dir:\", WORK_DIR)\n",
        "\n",
        "try:\n",
        "    import torch\n",
        "    print(\"CUDA available:\", torch.cuda.is_available())\n",
        "except Exception as e:\n",
        "    print(\"Torch not available:\", e)\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "def predict_test_template(test_input: pd.DataFrame, test_template: pd.DataFrame, models_x, models_y, feature_columns):\n",
        "    # Build last-frame features from observed test_input\n",
        "    feats = engineer_physics_features(test_input)\n",
        "    feats = add_sequence_features(feats)\n",
        "    feats = add_formation_features(feats)\n",
        "    feats = add_time_features(feats)\n",
        "    feats = add_motion_ema_features(feats)\n",
        "    feats = add_orientation_features(feats)\n",
        "    feats = add_geometric_features(feats)\n",
        "\n",
        "    gnn = compute_neighbor_embeddings(feats)\n",
        "\n",
        "    last_frames = (feats.sort_values(['game_id', 'play_id', 'nfl_id', 'frame_id'])\n",
        "                   .groupby(['game_id', 'play_id', 'nfl_id'], as_index=False)\n",
        "                   .tail(1)\n",
        "                   .rename(columns={'frame_id': 'last_frame_id'}))\n",
        "\n",
        "    last_frames = last_frames.merge(gnn, on=['game_id', 'play_id', 'nfl_id'], how='left')\n",
        "    if 'gnn_opp_dist_min' in last_frames.columns:\n",
        "        last_frames['pressure'] = 1.0 / (last_frames['gnn_opp_dist_min'] + 0.1)\n",
        "\n",
        "    # Expand to all required horizons in test.csv\n",
        "    future_rows = test_template.merge(last_frames, on=['game_id', 'play_id', 'nfl_id'], how='left')\n",
        "\n",
        "    future_rows['last_frame_id'] = future_rows['last_frame_id'].fillna(future_rows['frame_id'])\n",
        "    future_rows['delta_frames'] = (future_rows['frame_id'] - future_rows['last_frame_id']).clip(lower=0)\n",
        "    future_rows['delta_t'] = (future_rows['delta_frames'] / 10.0).fillna(0.0)\n",
        "    future_rows['waypoint_idx'] = (np.maximum(future_rows['delta_frames'] - 1, 0) // 10).astype(int)\n",
        "    future_rows['is_waypoint'] = (future_rows['delta_frames'] % 10 == 0).astype(int)\n",
        "\n",
        "    for col in feature_columns:\n",
        "        if col not in future_rows.columns:\n",
        "            future_rows[col] = 0\n",
        "\n",
        "    X_test = future_rows[feature_columns].fillna(0).values\n",
        "\n",
        "    baseline_x, baseline_y = steered_kinematics_baseline(\n",
        "        future_rows['x'].values,\n",
        "        future_rows['y'].values,\n",
        "        future_rows['velocity_x'].values,\n",
        "        future_rows['velocity_y'].values,\n",
        "        future_rows['ball_land_x'].values,\n",
        "        future_rows['ball_land_y'].values,\n",
        "        np.nan_to_num(future_rows['delta_t'].values, nan=0.0)\n",
        "    )\n",
        "\n",
        "    pred_rx = np.mean([m.predict(X_test) for m in models_x], axis=0)\n",
        "    pred_ry = np.mean([m.predict(X_test) for m in models_y], axis=0)\n",
        "\n",
        "    pred_x = np.clip(pred_rx + baseline_x, 0, 120)\n",
        "    pred_y = np.clip(pred_ry + baseline_y, 0, 53.3)\n",
        "\n",
        "    submission = test_template.copy()\n",
        "    submission['id'] = (submission['game_id'].astype(str) + '_' +\n",
        "                        submission['play_id'].astype(str) + '_' +\n",
        "                        submission['nfl_id'].astype(str) + '_' +\n",
        "                        submission['frame_id'].astype(str))\n",
        "    submission['x'] = pred_x\n",
        "    submission['y'] = pred_y\n",
        "    submission['x'] = submission['x'].fillna(0.0)\n",
        "    submission['y'] = submission['y'].fillna(0.0)\n",
        "    return submission[['id', 'x', 'y']]\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [
        {
          "ename": "ModuleNotFoundError",
          "evalue": "No module named 'catboost'",
          "output_type": "error",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
            "Cell \u001b[0;32mIn[3], line 12\u001b[0m\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01msklearn\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mmodel_selection\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m GroupKFold\n\u001b[1;32m     10\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01msklearn\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mmetrics\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m mean_squared_error\n\u001b[0;32m---> 12\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mcatboost\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m CatBoostRegressor, Pool \u001b[38;5;28;01mas\u001b[39;00m CatPool\n\u001b[1;32m     13\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mcatboost\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mutils\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m get_gpu_device_count\n\u001b[1;32m     15\u001b[0m \u001b[38;5;66;03m# Paths like Sample Notebooks\u001b[39;00m\n",
            "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'catboost'"
          ]
        }
      ],
      "source": [
        "# Self-contained pipeline (reads from /kaggle/input and writes submission.csv)\n",
        "import warnings\n",
        "warnings.filterwarnings(\"ignore\")\n",
        "\n",
        "import math\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "from pathlib import Path\n",
        "from sklearn.model_selection import GroupKFold\n",
        "from sklearn.metrics import mean_squared_error\n",
        "\n",
        "from catboost import CatBoostRegressor, Pool as CatPool\n",
        "from catboost.utils import get_gpu_device_count\n",
        "\n",
        "# Paths like Sample Notebooks\n",
        "DATA_DIR = Path(\"/kaggle/input/nfl-big-data-bowl-2026-prediction\")\n",
        "SAVE_PATH = Path(\"/kaggle/working/submission.csv\")\n",
        "\n",
        "# Fallback for local dry-runs (optional)\n",
        "if not DATA_DIR.exists():\n",
        "    DATA_DIR = Path.cwd() / \"kaggle\" / \"input\" / \"nfl-big-data-bowl-2026-prediction\"\n",
        "    SAVE_PATH = Path.cwd() / \"submission.csv\"\n",
        "\n",
        "# Config\n",
        "N_FOLDS = 5\n",
        "ITERATIONS = 10000\n",
        "LEARNING_RATE = 0.05\n",
        "DEPTH = 8\n",
        "L2_REG = 5.0\n",
        "EARLY_STOPPING = 800\n",
        "SEED = 42\n",
        "\n",
        "V_MAX = 7.5\n",
        "A_MAX = 3.0\n",
        "TURN_MAX_DEG = 120.0\n",
        "K_NEIGHBORS = 6\n",
        "RADIUS_LIMIT = 30.0\n",
        "TAU = 8.0\n",
        "try:\n",
        "    USE_GPU = get_gpu_device_count() > 0\n",
        "except Exception:\n",
        "    USE_GPU = False\n",
        "\n",
        "# Feature engineering\n",
        "\n",
        "def add_time_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.copy()\n",
        "    if 'num_frames_output' in df.columns:\n",
        "        max_frames = df['num_frames_output']\n",
        "    else:\n",
        "        max_frames = pd.Series(df.groupby(['game_id','play_id'])['frame_id'].transform('max'), index=df.index).fillna(30)\n",
        "    df['max_play_duration'] = max_frames / 10.0\n",
        "    df['frame_time'] = df['frame_id'] / 10.0\n",
        "    df['progress_ratio'] = (df['frame_id'] / np.maximum(max_frames, 1)).clip(0.0, 1.0)\n",
        "    df['time_remaining'] = (max_frames - df['frame_id']) / 10.0\n",
        "    df['frames_remaining'] = (max_frames - df['frame_id']).clip(lower=0)\n",
        "\n",
        "    # Ball-expected position and errors\n",
        "    df['expected_x_at_ball'] = df['x'] + df['velocity_x'] * df['frame_time']\n",
        "    df['expected_y_at_ball'] = df['y'] + df['velocity_y'] * df['frame_time']\n",
        "    if 'ball_land_x' in df.columns:\n",
        "        df['error_from_ball_x'] = df['expected_x_at_ball'] - df['ball_land_x']\n",
        "        df['error_from_ball_y'] = df['expected_y_at_ball'] - df['ball_land_y']\n",
        "        df['error_from_ball'] = np.sqrt(df['error_from_ball_x']**2 + df['error_from_ball_y']**2)\n",
        "        df['weighted_dist_by_time'] = df['dist_to_ball'] / (df['frame_time'] + 0.1)\n",
        "        df['dist_scaled_by_progress'] = df['dist_to_ball'] * (1.0 - df['progress_ratio'])\n",
        "    df['time_squared'] = df['frame_time'] ** 2\n",
        "    df['velocity_x_progress'] = df['velocity_x'] * df['progress_ratio']\n",
        "    df['velocity_y_progress'] = df['velocity_y'] * df['progress_ratio']\n",
        "    df['speed_scaled_by_time_left'] = df['s'] * df['time_remaining']\n",
        "    df['actual_play_length'] = max_frames\n",
        "    df['length_ratio'] = max_frames / 30.0\n",
        "    return df\n",
        "\n",
        "\n",
        "def add_motion_ema_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.copy()\n",
        "    g = df.groupby(['game_id','play_id','nfl_id'])\n",
        "    df['velocity_x_ema'] = g['velocity_x'].transform(lambda x: x.ewm(alpha=0.3, adjust=False).mean())\n",
        "    df['velocity_y_ema'] = g['velocity_y'].transform(lambda x: x.ewm(alpha=0.3, adjust=False).mean())\n",
        "    df['speed_ema'] = g['s'].transform(lambda x: x.ewm(alpha=0.3, adjust=False).mean())\n",
        "    return df\n",
        "\n",
        "\n",
        "def add_orientation_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.copy()\n",
        "    # orientation vs movement and towards ball\n",
        "    df['orientation_diff'] = np.abs(df['o'] - df['dir'])\n",
        "    df['orientation_diff'] = np.minimum(df['orientation_diff'], 360 - df['orientation_diff'])\n",
        "    dir_rad = np.radians(df['dir'].fillna(0.0))\n",
        "    df['velocity_alignment'] = np.cos(df['angle_to_ball'] - dir_rad)\n",
        "    return df\n",
        "\n",
        "\n",
        "def compute_geometric_endpoint(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.copy()\n",
        "    # time to endpoint (seconds) from available num_frames_output; fallback 3.0s\n",
        "    if 'num_frames_output' in df.columns:\n",
        "        t_total = df['num_frames_output'] / 10.0\n",
        "    else:\n",
        "        t_total = pd.Series(3.0, index=df.index)\n",
        "    df['geo_time_to_endpoint'] = t_total\n",
        "\n",
        "    # default: momentum projection\n",
        "    df['geo_endpoint_x'] = df['x'] + df['velocity_x'] * t_total\n",
        "    df['geo_endpoint_y'] = df['y'] + df['velocity_y'] * t_total\n",
        "\n",
        "    # targeted receiver → ball landing\n",
        "    if 'player_role' in df.columns:\n",
        "        recv_mask = (df['player_role'] == 'Targeted Receiver')\n",
        "        if 'ball_land_x' in df.columns:\n",
        "            df.loc[recv_mask, 'geo_endpoint_x'] = df.loc[recv_mask, 'ball_land_x']\n",
        "            df.loc[recv_mask, 'geo_endpoint_y'] = df.loc[recv_mask, 'ball_land_y']\n",
        "\n",
        "    # clip to field\n",
        "    df['geo_endpoint_x'] = df['geo_endpoint_x'].clip(0.0, 120.0)\n",
        "    df['geo_endpoint_y'] = df['geo_endpoint_y'].clip(0.0, 53.3)\n",
        "    return df\n",
        "\n",
        "\n",
        "def add_geometric_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = compute_geometric_endpoint(df)\n",
        "    # vector to geometric endpoint\n",
        "    df['geo_vector_x'] = df['geo_endpoint_x'] - df['x']\n",
        "    df['geo_vector_y'] = df['geo_endpoint_y'] - df['y']\n",
        "    df['geo_distance'] = np.sqrt(df['geo_vector_x']**2 + df['geo_vector_y']**2)\n",
        "\n",
        "    # required velocity to reach endpoint\n",
        "    t = df['geo_time_to_endpoint'].fillna(3.0) + 0.1\n",
        "    df['geo_required_vx'] = df['geo_vector_x'] / t\n",
        "    df['geo_required_vy'] = df['geo_vector_y'] / t\n",
        "\n",
        "    # velocity error relative to geometric path\n",
        "    df['geo_velocity_error_x'] = df['geo_required_vx'] - df['velocity_x']\n",
        "    df['geo_velocity_error_y'] = df['geo_required_vy'] - df['velocity_y']\n",
        "    df['geo_velocity_error'] = np.sqrt(df['geo_velocity_error_x']**2 + df['geo_velocity_error_y']**2)\n",
        "\n",
        "    # required constant acceleration to endpoint a = 2*dx/t^2\n",
        "    t_sq = t * t\n",
        "    df['geo_required_ax'] = (2.0 * df['geo_vector_x'] / t_sq).clip(-10.0, 10.0)\n",
        "    df['geo_required_ay'] = (2.0 * df['geo_vector_y'] / t_sq).clip(-10.0, 10.0)\n",
        "\n",
        "    # alignment with geometric path\n",
        "    vel_mag = np.sqrt(df['velocity_x']**2 + df['velocity_y']**2) + 0.1\n",
        "    geo_unit_x = df['geo_vector_x'] / (df['geo_distance'] + 0.1)\n",
        "    geo_unit_y = df['geo_vector_y'] / (df['geo_distance'] + 0.1)\n",
        "    df['geo_alignment'] = (df['velocity_x'] * geo_unit_x + df['velocity_y'] * geo_unit_y) / vel_mag\n",
        "    return df\n",
        "\n",
        "def height_to_inches(h):\n",
        "    try:\n",
        "        ft, inch = map(int, str(h).split('-'))\n",
        "        return ft * 12 + inch\n",
        "    except Exception:\n",
        "        return 72.0\n",
        "\n",
        "\n",
        "def engineer_physics_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.copy()\n",
        "    df['height_inches'] = df['player_height'].map(height_to_inches)\n",
        "    df['bmi'] = (df['player_weight'] / (df['height_inches']**2)) * 703.0\n",
        "\n",
        "    dir_rad = np.radians(df['dir'].fillna(0.0))\n",
        "    df['velocity_x'] = df['s'] * np.sin(dir_rad)\n",
        "    df['velocity_y'] = df['s'] * np.cos(dir_rad)\n",
        "    df['acceleration_x'] = df['a'] * np.cos(dir_rad)\n",
        "    df['acceleration_y'] = df['a'] * np.sin(dir_rad)\n",
        "\n",
        "    dx = df['ball_land_x'] - df['x']\n",
        "    dy = df['ball_land_y'] - df['y']\n",
        "    dist = np.sqrt(dx**2 + dy**2)\n",
        "    df['dist_to_ball'] = dist\n",
        "    df['angle_to_ball'] = np.arctan2(dy, dx)\n",
        "\n",
        "    ux = dx / (dist + 1e-6)\n",
        "    uy = dy / (dist + 1e-6)\n",
        "    vx = -uy\n",
        "    vy = ux\n",
        "\n",
        "    df['velocity_parallel'] = df['velocity_x'] * ux + df['velocity_y'] * uy\n",
        "    df['velocity_perpendicular'] = df['velocity_x'] * vx + df['velocity_y'] * vy\n",
        "    df['acceleration_parallel'] = df['acceleration_x'] * ux + df['acceleration_y'] * uy\n",
        "    df['acceleration_perpendicular'] = df['acceleration_x'] * vx + df['acceleration_y'] * vy\n",
        "\n",
        "    df['speed_squared'] = df['s'] ** 2\n",
        "    df['accel_magnitude'] = np.sqrt(df['acceleration_x']**2 + df['acceleration_y']**2)\n",
        "    df['momentum_x'] = df['player_weight'] * df['velocity_x']\n",
        "    df['momentum_y'] = df['player_weight'] * df['velocity_y']\n",
        "    df['kinetic_energy'] = 0.5 * df['player_weight'] * df['speed_squared']\n",
        "\n",
        "    df['role_targeted_receiver'] = (df['player_role'] == 'Targeted Receiver').astype(int)\n",
        "    df['role_defensive_coverage'] = (df['player_role'] == 'Defensive Coverage').astype(int)\n",
        "    df['role_passer'] = (df['player_role'] == 'Passer').astype(int)\n",
        "    df['side_offense'] = (df['player_side'] == 'Offense').astype(int)\n",
        "    return df\n",
        "\n",
        "\n",
        "def add_sequence_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.sort_values(['game_id', 'play_id', 'nfl_id', 'frame_id']).copy()\n",
        "    g = ['game_id', 'play_id', 'nfl_id']\n",
        "\n",
        "    for lag in [1, 2, 3, 4, 5]:\n",
        "        for col in ['x', 'y', 'velocity_x', 'velocity_y', 's', 'a',\n",
        "                    'velocity_parallel', 'velocity_perpendicular',\n",
        "                    'acceleration_parallel', 'acceleration_perpendicular']:\n",
        "            if col in df.columns:\n",
        "                df[f'{col}_lag{lag}'] = df.groupby(g)[col].shift(lag)\n",
        "\n",
        "    for window in [3, 5]:\n",
        "        for col in ['x', 'y', 'velocity_x', 'velocity_y', 's',\n",
        "                    'velocity_parallel', 'velocity_perpendicular']:\n",
        "            if col in df.columns:\n",
        "                df[f'{col}_rolling_mean_{window}'] = (\n",
        "                    df.groupby(g)[col].rolling(window, min_periods=1).mean().reset_index(level=[0, 1, 2], drop=True)\n",
        "                )\n",
        "                df[f'{col}_rolling_std_{window}'] = (\n",
        "                    df.groupby(g)[col].rolling(window, min_periods=1).std().reset_index(level=[0, 1, 2], drop=True)\n",
        "                )\n",
        "\n",
        "    for col in ['velocity_x', 'velocity_y', 'velocity_parallel', 'velocity_perpendicular']:\n",
        "        if col in df.columns:\n",
        "            df[f'{col}_delta'] = df.groupby(g)[col].diff()\n",
        "    return df\n",
        "\n",
        "\n",
        "def add_formation_features(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    df = df.copy()\n",
        "    grp = df.groupby(['game_id', 'play_id', 'frame_id', 'player_side'])\n",
        "    df['team_centroid_x'] = grp['x'].transform('mean')\n",
        "    df['team_centroid_y'] = grp['y'].transform('mean')\n",
        "    df['team_width'] = grp['y'].transform('std').fillna(0.0)\n",
        "    df['team_length'] = grp['x'].transform('std').fillna(0.0)\n",
        "\n",
        "    df['rel_centroid_x'] = df['x'] - df['team_centroid_x']\n",
        "    df['rel_centroid_y'] = df['y'] - df['team_centroid_y']\n",
        "\n",
        "    bearing = np.arctan2(df['ball_land_y'] - df['team_centroid_y'], df['ball_land_x'] - df['team_centroid_x'])\n",
        "    df['formation_bearing_sin'] = np.sin(bearing)\n",
        "    df['formation_bearing_cos'] = np.cos(bearing)\n",
        "    return df\n",
        "\n",
        "\n",
        "def compute_neighbor_embeddings(input_df: pd.DataFrame) -> pd.DataFrame:\n",
        "    cols = ['game_id', 'play_id', 'nfl_id', 'frame_id', 'x', 'y', 'velocity_x', 'velocity_y', 'player_side']\n",
        "    src = input_df[cols].copy()\n",
        "\n",
        "    last_frames = (src.sort_values(['game_id', 'play_id', 'nfl_id', 'frame_id'])\n",
        "                   .groupby(['game_id', 'play_id', 'nfl_id'], as_index=False)\n",
        "                   .tail(1)\n",
        "                   .rename(columns={'frame_id': 'last_frame_id'}))\n",
        "\n",
        "    neighbors = last_frames.merge(src.rename(columns={'frame_id': 'nb_frame_id', 'nfl_id': 'nfl_id_nb',\n",
        "                                                      'x': 'x_nb', 'y': 'y_nb',\n",
        "                                                      'velocity_x': 'vx_nb', 'velocity_y': 'vy_nb',\n",
        "                                                      'player_side': 'player_side_nb'}),\n",
        "                                  left_on=['game_id', 'play_id', 'last_frame_id'],\n",
        "                                  right_on=['game_id', 'play_id', 'nb_frame_id'], how='left')\n",
        "    neighbors = neighbors[neighbors['nfl_id_nb'] != neighbors['nfl_id']]\n",
        "\n",
        "    neighbors['dx'] = neighbors['x_nb'] - neighbors['x']\n",
        "    neighbors['dy'] = neighbors['y_nb'] - neighbors['y']\n",
        "    neighbors['dvx'] = neighbors['vx_nb'] - neighbors['velocity_x']\n",
        "    neighbors['dvy'] = neighbors['vy_nb'] - neighbors['velocity_y']\n",
        "    neighbors['dist'] = np.sqrt(neighbors['dx']**2 + neighbors['dy']**2)\n",
        "\n",
        "    neighbors = neighbors[np.isfinite(neighbors['dist']) & (neighbors['dist'] > 1e-6) & (neighbors['dist'] <= RADIUS_LIMIT)]\n",
        "    neighbors['is_ally'] = (neighbors['player_side_nb'].fillna(\"\") == neighbors['player_side'].fillna(\"\")).astype(float)\n",
        "\n",
        "    keys = ['game_id', 'play_id', 'nfl_id']\n",
        "    neighbors['rank'] = neighbors.groupby(keys)['dist'].rank(method='first')\n",
        "    neighbors = neighbors[neighbors['rank'] <= K_NEIGHBORS]\n",
        "\n",
        "    neighbors['weight'] = np.exp(-neighbors['dist'] / TAU)\n",
        "    sumw = neighbors.groupby(keys)['weight']. transform('sum')\n",
        "    neighbors['weight_norm'] = np.where(sumw > 0, neighbors['weight'] / sumw, 0.0)\n",
        "\n",
        "    neighbors['weight_ally'] = neighbors['weight_norm'] * neighbors['is_ally']\n",
        "    neighbors['weight_opp'] = neighbors['weight_norm'] * (1.0 - neighbors['is_ally'])\n",
        "\n",
        "    for c in ['dx', 'dy', 'dvx', 'dvy']:\n",
        "        neighbors[f'{c}_ally_weighted'] = neighbors[c] * neighbors['weight_ally']\n",
        "        neighbors[f'{c}_opp_weighted'] = neighbors[c] * neighbors['weight_opp']\n",
        "\n",
        "    emb = neighbors.groupby(keys).agg(\n",
        "        gnn_ally_dx_mean=('dx_ally_weighted', 'sum'),\n",
        "        gnn_ally_dy_mean=('dy_ally_weighted', 'sum'),\n",
        "        gnn_ally_dvx_mean=('dvx_ally_weighted', 'sum'),\n",
        "        gnn_ally_dvy_mean=('dvy_ally_weighted', 'sum'),\n",
        "        gnn_opp_dx_mean=('dx_opp_weighted', 'sum'),\n",
        "        gnn_opp_dy_mean=('dy_opp_weighted', 'sum'),\n",
        "        gnn_opp_dvx_mean=('dvx_opp_weighted', 'sum'),\n",
        "        gnn_opp_dvy_mean=('dvy_opp_weighted', 'sum'),\n",
        "        gnn_ally_count=('is_ally', 'sum'),\n",
        "        gnn_opp_count=('is_ally', lambda x: len(x) - x.sum()),\n",
        "        gnn_ally_dist_min=('dist', lambda x: x[neighbors.loc[x.index, 'is_ally'] > 0.5].min() if (neighbors.loc[x.index, 'is_ally'] > 0.5).any() else RADIUS_LIMIT),\n",
        "        gnn_opp_dist_min=('dist', lambda x: x[neighbors.loc[x.index, 'is_ally'] < 0.5].min() if (neighbors.loc[x.index, 'is_ally'] < 0.5).any() else RADIUS_LIMIT)\n",
        "    ).reset_index()\n",
        "\n",
        "    for c in ['gnn_ally_dx_mean', 'gnn_ally_dy_mean', 'gnn_ally_dvx_mean', 'gnn_ally_dvy_mean', 'gnn_opp_dx_mean', 'gnn_opp_dy_mean', 'gnn_opp_dvx_mean', 'gnn_opp_dvy_mean']:\n",
        "        emb[c] = emb[c].fillna(0.0)\n",
        "    for c in ['gnn_ally_count', 'gnn_opp_count']:\n",
        "        emb[c] = emb[c].fillna(0.0)\n",
        "    for c in ['gnn_ally_dist_min', 'gnn_opp_dist_min']:\n",
        "        emb[c] = emb[c].fillna(RADIUS_LIMIT)\n",
        "    return emb\n",
        "\n",
        "# Physics baseline\n",
        "\n",
        "def steered_kinematics_baseline(x, y, vx, vy, ball_x, ball_y, dt, v_max=V_MAX, a_max=A_MAX, turn_rate_max_deg=TURN_MAX_DEG):\n",
        "    eps = 1e-6\n",
        "    speed = np.sqrt(vx**2 + vy**2)\n",
        "    cur_dir = np.where(speed > eps, np.arctan2(vx, vy), np.arctan2(ball_y - y, ball_x - x))\n",
        "    desired_dir = np.arctan2(ball_y - y, ball_x - x)\n",
        "\n",
        "    ang_diff = (desired_dir - cur_dir + np.pi) % (2 * np.pi) - np.pi\n",
        "    max_turn = np.radians(turn_rate_max_deg) * dt\n",
        "    ang_step = np.clip(ang_diff, -max_turn, max_turn)\n",
        "    new_dir = cur_dir + ang_step\n",
        "\n",
        "    target_speed = np.minimum(v_max, speed + a_max * dt)\n",
        "    vx_new = target_speed * np.sin(new_dir)\n",
        "    vy_new = target_speed * np.cos(new_dir)\n",
        "\n",
        "    pred_x = x + 0.5 * (vx + vx_new) * dt\n",
        "    pred_y = y + 0.5 * (vy + vy_new) * dt\n",
        "\n",
        "    pred_x = np.clip(pred_x, 0.0, 120.0)\n",
        "    pred_y = np.clip(pred_y, 0.0, 53.3)\n",
        "    return pred_x, pred_y\n",
        "\n",
        "# Feature list\n",
        "\n",
        "def build_feature_list(df: pd.DataFrame):\n",
        "    base = [\n",
        "        'x', 'y', 's', 'a', 'o', 'dir',\n",
        "        'velocity_x', 'velocity_y', 'acceleration_x', 'acceleration_y',\n",
        "        'velocity_parallel', 'velocity_perpendicular',\n",
        "        'acceleration_parallel', 'acceleration_perpendicular',\n",
        "        'player_weight', 'height_inches', 'bmi',\n",
        "        'ball_land_x', 'ball_land_y', 'dist_to_ball', 'angle_to_ball',\n",
        "        'speed_squared', 'accel_magnitude', 'momentum_x', 'momentum_y', 'kinetic_energy',\n",
        "        'role_targeted_receiver', 'role_defensive_coverage', 'role_passer', 'side_offense',\n",
        "        'team_centroid_x', 'team_centroid_y', 'team_width', 'team_length',\n",
        "        'rel_centroid_x', 'rel_centroid_y', 'formation_bearing_sin', 'formation_bearing_cos',\n",
        "        'delta_frames', 'delta_t', 'frame_id', 'waypoint_idx', 'is_waypoint',\n",
        "        'pressure'\n",
        "    ]\n",
        "    # Geometric features (inspired by leader notebook)\n",
        "    geo = [\n",
        "        'geo_time_to_endpoint', 'geo_endpoint_x', 'geo_endpoint_y',\n",
        "        'geo_vector_x', 'geo_vector_y', 'geo_distance',\n",
        "        'geo_required_vx', 'geo_required_vy',\n",
        "        'geo_velocity_error_x', 'geo_velocity_error_y', 'geo_velocity_error',\n",
        "        'geo_required_ax', 'geo_required_ay', 'geo_alignment'\n",
        "    ]\n",
        "    gnn = [c for c in df.columns if c.startswith('gnn_')]\n",
        "\n",
        "    lags = []\n",
        "    for lag in [1, 2, 3, 4, 5]:\n",
        "        for col in ['x', 'y', 'velocity_x', 'velocity_y', 's', 'a',\n",
        "                    'velocity_parallel', 'velocity_perpendicular',\n",
        "                    'acceleration_parallel', 'acceleration_perpendicular']:\n",
        "            lags.append(f'{col}_lag{lag}')\n",
        "\n",
        "    rolls = []\n",
        "    for window in [3, 5]:\n",
        "        for col in ['x', 'y', 'velocity_x', 'velocity_y', 's',\n",
        "                    'velocity_parallel', 'velocity_perpendicular']:\n",
        "            rolls.extend([f'{col}_rolling_mean_{window}', f'{col}_rolling_std_{window}'])\n",
        "\n",
        "    deltas = ['velocity_x_delta', 'velocity_y_delta', 'velocity_parallel_delta', 'velocity_perpendicular_delta']\n",
        "\n",
        "    all_cols = base + geo + gnn + lags + rolls + deltas\n",
        "    return [c for c in all_cols if c in df.columns]\n",
        "\n",
        "# Prepare training data\n",
        "\n",
        "def prepare_training_data(input_df: pd.DataFrame, output_df: pd.DataFrame) -> pd.DataFrame:\n",
        "    feats = engineer_physics_features(input_df)\n",
        "    feats = add_sequence_features(feats)\n",
        "    feats = add_formation_features(feats)\n",
        "    feats = add_time_features(feats)\n",
        "    feats = add_motion_ema_features(feats)\n",
        "    feats = add_orientation_features(feats)\n",
        "    feats = add_geometric_features(feats)\n",
        "\n",
        "    gnn = compute_neighbor_embeddings(feats)\n",
        "\n",
        "    last_frames = (feats.sort_values(['game_id', 'play_id', 'nfl_id', 'frame_id'])\n",
        "                   .groupby(['game_id', 'play_id', 'nfl_id'], as_index=False)\n",
        "                   .tail(1)\n",
        "                   .rename(columns={'frame_id': 'last_frame_id'}))\n",
        "\n",
        "    last_frames = last_frames.merge(gnn, on=['game_id', 'play_id', 'nfl_id'], how='left')\n",
        "    # pressure from nearest opponent distance\n",
        "    if 'gnn_opp_dist_min' in last_frames.columns:\n",
        "        last_frames['pressure'] = 1.0 / (last_frames['gnn_opp_dist_min'] + 0.1)\n",
        "\n",
        "    out = output_df.rename(columns={'x': 'target_x', 'y': 'target_y'}).copy()\n",
        "\n",
        "    train = out.merge(last_frames, on=['game_id', 'play_id', 'nfl_id'], how='left')\n",
        "    train['delta_frames'] = (train['frame_id'] - train['last_frame_id']).clip(lower=0)\n",
        "    train['delta_t'] = train['delta_frames'] / 10.0\n",
        "    train['waypoint_idx'] = (np.maximum(train['delta_frames'] - 1, 0) // 10).astype(int)\n",
        "    train['is_waypoint'] = (train['delta_frames'] % 10 == 0).astype(int)\n",
        "    return train\n",
        "\n",
        "# Train CatBoost residual models\n",
        "\n",
        "def train_catboost_models(training_data: pd.DataFrame):\n",
        "    features = build_feature_list(training_data)\n",
        "    X = training_data[features].fillna(0).values\n",
        "    y_x = training_data['target_x'].values\n",
        "    y_y = training_data['target_y'].values\n",
        "\n",
        "    baseline_x, baseline_y = steered_kinematics_baseline(\n",
        "        training_data['x'].values,\n",
        "        training_data['y'].values,\n",
        "        training_data['velocity_x'].values,\n",
        "        training_data['velocity_y'].values,\n",
        "        training_data['ball_land_x'].values,\n",
        "        training_data['ball_land_y'].values,\n",
        "        training_data['delta_t'].values\n",
        "    )\n",
        "    residual_x = y_x - baseline_x\n",
        "    residual_y = y_y - baseline_y\n",
        "\n",
        "    groups = training_data['game_id'].astype(str) + '_' + training_data['play_id'].astype(str)\n",
        "    gkf = GroupKFold(n_splits=N_FOLDS)\n",
        "\n",
        "    params = {\n",
        "        'iterations': ITERATIONS,\n",
        "        'learning_rate': LEARNING_RATE,\n",
        "        'depth': DEPTH,\n",
        "        'l2_leaf_reg': L2_REG,\n",
        "        'random_seed': SEED,\n",
        "        'task_type': 'GPU' if USE_GPU else 'CPU',\n",
        "        'loss_function': 'RMSE',\n",
        "        'early_stopping_rounds': EARLY_STOPPING,\n",
        "        'verbose': 200\n",
        "    }\n",
        "\n",
        "    models_x, models_y, fold_scores = [], [], []\n",
        "\n",
        "    for fold, (tr, va) in enumerate(gkf.split(X, groups=groups), 1):\n",
        "        print(f\"\\nFold {fold}/{N_FOLDS}\")\n",
        "        X_tr, X_va = X[tr], X[va]\n",
        "        yx_tr, yx_va = residual_x[tr], residual_x[va]\n",
        "        yy_tr, yy_va = residual_y[tr], residual_y[va]\n",
        "\n",
        "        mx = CatBoostRegressor(**params)\n",
        "        my = CatBoostRegressor(**params)\n",
        "        mx.fit(CatPool(X_tr, yx_tr), eval_set=CatPool(X_va, yx_va))\n",
        "        my.fit(CatPool(X_tr, yy_tr), eval_set=CatPool(X_va, yy_va))\n",
        "\n",
        "        models_x.append(mx)\n",
        "        models_y.append(my)\n",
        "\n",
        "        pred_rx = mx.predict(X_va)\n",
        "        pred_ry = my.predict(X_va)\n",
        "        pred_x = np.clip(pred_rx + baseline_x[va], 0, 120)\n",
        "        pred_y = np.clip(pred_ry + baseline_y[va], 0, 53.3)\n",
        "        rmse = math.sqrt(0.5 * (mean_squared_error(y_x[va], pred_x) + mean_squared_error(y_y[va], pred_y)))\n",
        "        print(f\"Fold {fold} RMSE: {rmse:.5f}\")\n",
        "        fold_scores.append(rmse)\n",
        "\n",
        "    print(f\"\\nCV Scores: {[f'{s:.5f}' for s in fold_scores]}\")\n",
        "    print(f\"Mean CV RMSE: {np.mean(fold_scores):.5f} ± {np.std(fold_scores):.5f}\")\n",
        "    return models_x, models_y, features\n",
        "\n",
        "# Predict test\n",
        "\n",
        "def predict_test(test_input: pd.DataFrame, test_template: pd.DataFrame, models_x, models_y, feature_columns):\n",
        "    feats = engineer_physics_features(test_input)\n",
        "    feats = add_sequence_features(feats)\n",
        "    feats = add_formation_features(feats)\n",
        "    feats = add_time_features(feats)\n",
        "    feats = add_motion_ema_features(feats)\n",
        "    feats = add_orientation_features(feats)\n",
        "    feats = add_geometric_features(feats)\n",
        "\n",
        "    gnn = compute_neighbor_embeddings(feats)\n",
        "\n",
        "    last_frames = (feats.sort_values(['game_id', 'play_id', 'nfl_id', 'frame_id'])\n",
        "                   .groupby(['game_id', 'play_id', 'nfl_id'], as_index=False)\n",
        "                   .tail(1)\n",
        "                   .rename(columns={'frame_id': 'last_frame_id'}))\n",
        "\n",
        "    last_frames = last_frames.merge(gnn, on=['game_id', 'play_id', 'nfl_id'], how='left')\n",
        "    # pressure from nearest opponent distance\n",
        "    if 'gnn_opp_dist_min' in last_frames.columns:\n",
        "        last_frames['pressure'] = 1.0 / (last_frames['gnn_opp_dist_min'] + 0.1)\n",
        "\n",
        "    test_prepared = test_input.merge(last_frames, on=['game_id', 'play_id', 'nfl_id'], how='left')\n",
        "\n",
        "    # Fill missing last_frame_id with current frame to ensure zero delta\n",
        "    test_prepared['last_frame_id'] = test_prepared['last_frame_id'].fillna(test_prepared['frame_id'])\n",
        "    test_prepared['delta_frames'] = (test_prepared['frame_id'] - test_prepared['last_frame_id']).clip(lower=0)\n",
        "    test_prepared['delta_t'] = (test_prepared['delta_frames'] / 10.0).fillna(0.0)\n",
        "    test_prepared['waypoint_idx'] = (np.maximum(test_prepared['delta_frames'] - 1, 0) // 10).astype(int)\n",
        "    test_prepared['is_waypoint'] = (test_prepared['delta_frames'] % 10 == 0).astype(int)\n",
        "\n",
        "    for col in feature_columns:\n",
        "        if col not in test_prepared.columns:\n",
        "            test_prepared[col] = 0\n",
        "\n",
        "    X_test = test_prepared[feature_columns].fillna(0).values\n",
        "\n",
        "    baseline_x, baseline_y = steered_kinematics_baseline(\n",
        "        test_prepared['x'].values,\n",
        "        test_prepared['y'].values,\n",
        "        test_prepared['velocity_x'].values,\n",
        "        test_prepared['velocity_y'].values,\n",
        "        test_prepared['ball_land_x'].values,\n",
        "        test_prepared['ball_land_y'].values,\n",
        "        np.nan_to_num(test_prepared['delta_t'].values, nan=0.0)\n",
        "    )\n",
        "\n",
        "    pred_rx = np.mean([m.predict(X_test) for m in models_x], axis=0)\n",
        "    pred_ry = np.mean([m.predict(X_test) for m in models_y], axis=0)\n",
        "\n",
        "    pred_x = np.clip(pred_rx + baseline_x, 0, 120)\n",
        "    pred_y = np.clip(pred_ry + baseline_y, 0, 53.3)\n",
        "\n",
        "    # Build id for all rows in test_input\n",
        "    pred_df = pd.DataFrame({\n",
        "        'id': test_input['game_id'].astype(str) + '_' + test_input['play_id'].astype(str) + '_' + test_input['nfl_id'].astype(str) + '_' + test_input['frame_id'].astype(str),\n",
        "        'x': pred_x,\n",
        "        'y': pred_y\n",
        "    })\n",
        "\n",
        "    # Create submission in exact test_template order\n",
        "    sub_ids = (test_template['game_id'].astype(str) + '_' +\n",
        "               test_template['play_id'].astype(str) + '_' +\n",
        "               test_template['nfl_id'].astype(str) + '_' +\n",
        "               test_template['frame_id'].astype(str))\n",
        "\n",
        "    submission = pd.DataFrame({'id': sub_ids})\n",
        "    submission = submission.merge(pred_df, on='id', how='left')\n",
        "\n",
        "    # Any missing predictions default to zeros (rare)\n",
        "    submission['x'] = submission['x'].fillna(0.0)\n",
        "    submission['y'] = submission['y'].fillna(0.0)\n",
        "    return submission\n",
        "\n",
        "# Load data exactly like Sample Notebooks\n",
        "print(\"\\n[1/3] Loading data...\")\n",
        "train_input_files = [DATA_DIR / f\"train/input_2023_w{w:02d}.csv\" for w in range(1, 19)]\n",
        "train_output_files = [DATA_DIR / f\"train/output_2023_w{w:02d}.csv\" for w in range(1, 19)]\n",
        "\n",
        "train_input = pd.concat([pd.read_csv(f) for f in train_input_files if f.exists()])\n",
        "train_output = pd.concat([pd.read_csv(f) for f in train_output_files if f.exists()])\n",
        "\n",
        "test_input = pd.read_csv(DATA_DIR / \"test_input.csv\")\n",
        "test_template = pd.read_csv(DATA_DIR / \"test.csv\")\n",
        "\n",
        "print(\"[2/3] Preparing training data and training CatBoost (residuals)...\")\n",
        "training_data = prepare_training_data(train_input, train_output)\n",
        "models_x, models_y, feature_columns = train_catboost_models(training_data)\n",
        "\n",
        "print(\"[3/3] Predicting on test and writing submission.csv ...\")\n",
        "submission = predict_test(test_input, test_template, models_x, models_y, feature_columns)\n",
        "submission = submission[['id', 'x', 'y']].astype({'id': str, 'x': float, 'y': float})\n",
        "submission.to_csv(SAVE_PATH, index=False)\n",
        "print(f\"Saved submission to {SAVE_PATH}\")\n",
        "\n",
        "# Kaggle expects a root-level submission.csv\n",
        "if str(SAVE_PATH) != 'submission.csv':\n",
        "    try:\n",
        "        import shutil\n",
        "        shutil.copy(str(SAVE_PATH), 'submission.csv')\n",
        "    except Exception:\n",
        "        pass\n",
        "\n",
        "submission.head()\n"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "data-science",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.2"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}
